import type { Problem } from '@/types/problem';

export const problem: Problem = {
  id: 'database-007', level: 'database', order: 7,
  title: { ko: '인덱스 사용률 분석', en: 'Index Usage Analysis' },
  description: {
    ko: `모든 인덱스의 **사용률과 크기**를 분석하세요.\n\n### 요구사항\n\`\`\`sql\nSELECT\n  schemaname,\n  relname AS table_name,\n  indexrelname AS index_name,\n  idx_scan AS times_used,\n  pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,\n  CASE\n    WHEN idx_scan = 0 THEN 'Unused'\n    WHEN idx_scan < 10 THEN 'Rarely used'\n    ELSE 'Active'\n  END AS usage_status\nFROM pg_stat_user_indexes\nORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC;\n\`\`\`\n\n### 왜 중요한가?\n- **미사용 인덱스**는 디스크만 차지하고 INSERT/UPDATE 성능을 저하\n- 인덱스 사용률을 분석하여 불필요한 인덱스 제거 가능\n- DBA의 핵심 최적화 업무`,
    en: `Analyze **usage rates and sizes** of all indexes.\n\n### Requirements\n\`\`\`sql\nSELECT\n  schemaname,\n  relname AS table_name,\n  indexrelname AS index_name,\n  idx_scan AS times_used,\n  pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,\n  CASE\n    WHEN idx_scan = 0 THEN 'Unused'\n    WHEN idx_scan < 10 THEN 'Rarely used'\n    ELSE 'Active'\n  END AS usage_status\nFROM pg_stat_user_indexes\nORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC;\n\`\`\`\n\n### Why is this important?\n- **Unused indexes** waste disk and slow down INSERT/UPDATE\n- Analyze usage to identify removable indexes\n- Core DBA optimization task`,
  },
  schema: 'ecommerce', category: 'Performance', difficulty: 2,
  hints: {
    ko: ['pg_stat_user_indexes에서 인덱스 사용 통계를 확인합니다.', 'idx_scan = 0인 인덱스는 미사용 인덱스입니다.', "SELECT schemaname, relname AS table_name, indexrelname AS index_name, idx_scan AS times_used, pg_size_pretty(pg_relation_size(indexrelid)) AS index_size, CASE WHEN idx_scan = 0 THEN 'Unused' WHEN idx_scan < 10 THEN 'Rarely used' ELSE 'Active' END AS usage_status FROM pg_stat_user_indexes ORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC;"],
    en: ['Check index usage statistics in pg_stat_user_indexes.', 'Indexes with idx_scan = 0 are unused.', "SELECT schemaname, relname AS table_name, indexrelname AS index_name, idx_scan AS times_used, pg_size_pretty(pg_relation_size(indexrelid)) AS index_size, CASE WHEN idx_scan = 0 THEN 'Unused' WHEN idx_scan < 10 THEN 'Rarely used' ELSE 'Active' END AS usage_status FROM pg_stat_user_indexes ORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC;"],
  },
  explanation: {
    ko: `## 인덱스 사용률 분석\n\n### 미사용 인덱스 찾기\n\`\`\`sql\nSELECT indexrelname, relname,\n       pg_size_pretty(pg_relation_size(indexrelid)) AS size\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\n  AND indexrelname NOT LIKE '%_pkey'  -- PK 제외\nORDER BY pg_relation_size(indexrelid) DESC;\n\`\`\`\n\n### 중복 인덱스 찾기\n\`\`\`sql\nSELECT a.indexrelname AS index1,\n       b.indexrelname AS index2,\n       a.relname AS table_name\nFROM pg_stat_user_indexes a\nJOIN pg_stat_user_indexes b ON a.relid = b.relid\n  AND a.indexrelid < b.indexrelid\nWHERE a.indexrelname != b.indexrelname;\n\`\`\`\n\n### 인덱스 최적화 가이드\n| 상황 | 조치 |\n|------|------|\n| idx_scan = 0 | 인덱스 삭제 검토 |\n| 크기 > 테이블 크기 | 인덱스 재구성 |\n| seq_scan >> idx_scan | 인덱스 추가 필요 |\n| 복합 인덱스 겹침 | 중복 제거 |\n\n### 인덱스 삭제 전 체크리스트\n- 충분한 기간(최소 1주일) 통계 수집 확인\n- 배치 작업에서만 사용되는 인덱스가 아닌지 확인\n- PK/UK 인덱스는 제약조건과 연결되므로 주의`,
    en: `## Index Usage Analysis\n\n### Find Unused Indexes\n\`\`\`sql\nSELECT indexrelname, relname,\n       pg_size_pretty(pg_relation_size(indexrelid)) AS size\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\n  AND indexrelname NOT LIKE '%_pkey'  -- Exclude PKs\nORDER BY pg_relation_size(indexrelid) DESC;\n\`\`\`\n\n### Find Duplicate Indexes\n\`\`\`sql\nSELECT a.indexrelname AS index1,\n       b.indexrelname AS index2,\n       a.relname AS table_name\nFROM pg_stat_user_indexes a\nJOIN pg_stat_user_indexes b ON a.relid = b.relid\n  AND a.indexrelid < b.indexrelid\nWHERE a.indexrelname != b.indexrelname;\n\`\`\`\n\n### Index Optimization Guide\n| Situation | Action |\n|-----------|--------|\n| idx_scan = 0 | Consider dropping |\n| Size > table size | Rebuild index |\n| seq_scan >> idx_scan | Add index |\n| Overlapping composites | Remove duplicates |\n\n### Checklist Before Dropping\n- Ensure sufficient monitoring period (min 1 week)\n- Check if used only by batch jobs\n- PK/UK indexes are tied to constraints`,
  },
  expectedQuery: {
    postgresql: "SELECT schemaname, relname AS table_name, indexrelname AS index_name, idx_scan AS times_used, pg_size_pretty(pg_relation_size(indexrelid)) AS index_size, CASE WHEN idx_scan = 0 THEN 'Unused' WHEN idx_scan < 10 THEN 'Rarely used' ELSE 'Active' END AS usage_status FROM pg_stat_user_indexes ORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC;",
    mysql: "SELECT schemaname, relname AS table_name, indexrelname AS index_name, idx_scan AS times_used, pg_size_pretty(pg_relation_size(indexrelid)) AS index_size, CASE WHEN idx_scan = 0 THEN 'Unused' WHEN idx_scan < 10 THEN 'Rarely used' ELSE 'Active' END AS usage_status FROM pg_stat_user_indexes ORDER BY idx_scan ASC, pg_relation_size(indexrelid) DESC;",
  },
  gradingMode: 'exact', relatedConcepts: ['pg_stat_user_indexes', 'Index', 'Performance', 'Optimization', 'DBA'],
};
