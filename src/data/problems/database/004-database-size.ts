import type { Problem } from '@/types/problem';

export const problem: Problem = {
  id: 'database-004', level: 'database', order: 4,
  title: { ko: '데이터베이스/테이블 크기 조회', en: 'Database & Table Size Monitoring' },
  description: {
    ko: `데이터베이스와 각 테이블의 **디스크 사용량**을 조회하세요.\n\n### 요구사항\n\`\`\`sql\nSELECT\n  relname AS table_name,\n  pg_size_pretty(pg_total_relation_size(relid)) AS total_size,\n  pg_size_pretty(pg_relation_size(relid)) AS data_size,\n  pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS index_size\nFROM pg_stat_user_tables\nORDER BY pg_total_relation_size(relid) DESC;\n\`\`\`\n\n### 주요 함수\n| 함수 | 설명 |\n|------|------|\n| pg_database_size() | 데이터베이스 전체 크기 |\n| pg_total_relation_size() | 테이블 + 인덱스 + TOAST |\n| pg_relation_size() | 테이블 데이터만 |\n| pg_size_pretty() | 바이트를 읽기 쉬운 형태로 |`,
    en: `Query **disk usage** for database and tables.\n\n### Requirements\n\`\`\`sql\nSELECT\n  relname AS table_name,\n  pg_size_pretty(pg_total_relation_size(relid)) AS total_size,\n  pg_size_pretty(pg_relation_size(relid)) AS data_size,\n  pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS index_size\nFROM pg_stat_user_tables\nORDER BY pg_total_relation_size(relid) DESC;\n\`\`\`\n\n### Key Functions\n| Function | Description |\n|----------|-------------|\n| pg_database_size() | Total database size |\n| pg_total_relation_size() | Table + indexes + TOAST |\n| pg_relation_size() | Table data only |\n| pg_size_pretty() | Human-readable bytes |`,
  },
  schema: 'ecommerce', category: 'Monitoring', difficulty: 1,
  hints: {
    ko: ['pg_size_pretty()로 바이트를 MB/GB 형태로 변환합니다.', 'pg_total_relation_size - pg_relation_size로 인덱스 크기를 계산합니다.', "SELECT relname AS table_name, pg_size_pretty(pg_total_relation_size(relid)) AS total_size, pg_size_pretty(pg_relation_size(relid)) AS data_size, pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS index_size FROM pg_stat_user_tables ORDER BY pg_total_relation_size(relid) DESC;"],
    en: ['Use pg_size_pretty() to convert bytes to MB/GB format.', 'Subtract pg_relation_size from pg_total_relation_size for index size.', "SELECT relname AS table_name, pg_size_pretty(pg_total_relation_size(relid)) AS total_size, pg_size_pretty(pg_relation_size(relid)) AS data_size, pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS index_size FROM pg_stat_user_tables ORDER BY pg_total_relation_size(relid) DESC;"],
  },
  explanation: {
    ko: `## 데이터베이스/테이블 크기 모니터링\n\n### 데이터베이스 전체 크기\n\`\`\`sql\nSELECT pg_size_pretty(pg_database_size(current_database())) AS db_size;\n\`\`\`\n\n### 테이블별 크기 (인덱스 포함)\n\`\`\`sql\nSELECT relname,\n       pg_size_pretty(pg_total_relation_size(relid)) AS total,\n       pg_size_pretty(pg_relation_size(relid)) AS data,\n       pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS indexes\nFROM pg_stat_user_tables\nORDER BY pg_total_relation_size(relid) DESC;\n\`\`\`\n\n### 인덱스 크기 상세\n\`\`\`sql\nSELECT indexrelname AS index_name,\n       pg_size_pretty(pg_relation_size(indexrelid)) AS index_size\nFROM pg_stat_user_indexes\nORDER BY pg_relation_size(indexrelid) DESC;\n\`\`\`\n\n### DBA 활용\n- **디스크 용량 관리**: 큰 테이블/인덱스 식별\n- **테이블 비대화 감지**: 데이터 대비 인덱스 크기가 과도한 경우\n- **용량 계획**: 성장 추세를 기반으로 디스크 확보\n- **TOAST 테이블**: 대형 값(TEXT, JSONB)의 별도 저장 확인`,
    en: `## Database & Table Size Monitoring\n\n### Full Database Size\n\`\`\`sql\nSELECT pg_size_pretty(pg_database_size(current_database())) AS db_size;\n\`\`\`\n\n### Per-Table Size (Including Indexes)\n\`\`\`sql\nSELECT relname,\n       pg_size_pretty(pg_total_relation_size(relid)) AS total,\n       pg_size_pretty(pg_relation_size(relid)) AS data,\n       pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS indexes\nFROM pg_stat_user_tables\nORDER BY pg_total_relation_size(relid) DESC;\n\`\`\`\n\n### Detailed Index Sizes\n\`\`\`sql\nSELECT indexrelname AS index_name,\n       pg_size_pretty(pg_relation_size(indexrelid)) AS index_size\nFROM pg_stat_user_indexes\nORDER BY pg_relation_size(indexrelid) DESC;\n\`\`\`\n\n### DBA Uses\n- **Disk management**: Identify large tables/indexes\n- **Bloat detection**: Excessive index size vs data\n- **Capacity planning**: Project disk needs from growth trends\n- **TOAST tables**: Separate storage for large values (TEXT, JSONB)`,
  },
  expectedQuery: {
    postgresql: 'SELECT relname AS table_name, pg_size_pretty(pg_total_relation_size(relid)) AS total_size, pg_size_pretty(pg_relation_size(relid)) AS data_size, pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS index_size FROM pg_stat_user_tables ORDER BY pg_total_relation_size(relid) DESC;',
    mysql: 'SELECT relname AS table_name, pg_size_pretty(pg_total_relation_size(relid)) AS total_size, pg_size_pretty(pg_relation_size(relid)) AS data_size, pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS index_size FROM pg_stat_user_tables ORDER BY pg_total_relation_size(relid) DESC;',
  },
  gradingMode: 'exact', relatedConcepts: ['pg_size_pretty', 'pg_total_relation_size', 'Monitoring', 'Disk Usage', 'DBA'],
};
