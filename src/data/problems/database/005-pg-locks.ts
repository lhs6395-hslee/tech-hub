import type { Problem } from '@/types/problem';

export const problem: Problem = {
  id: 'database-005', level: 'database', order: 5,
  title: { ko: 'pg_locks: 잠금 모니터링', en: 'pg_locks: Lock Monitoring' },
  description: {
    ko: `현재 데이터베이스의 **잠금(Lock) 상태**를 조회하세요.\n\n### 요구사항\n\`\`\`sql\nSELECT\n  l.locktype,\n  l.mode,\n  l.granted,\n  l.pid,\n  a.usename,\n  a.query,\n  a.state\nFROM pg_locks l\nJOIN pg_stat_activity a ON l.pid = a.pid\nWHERE a.datname = current_database()\n  AND l.locktype = 'relation'\nORDER BY l.granted, l.pid;\n\`\`\`\n\n### Lock이란?\n- 동시에 여러 트랜잭션이 같은 데이터를 수정하지 못하게 하는 메커니즘\n- **granted = true**: 잠금 획득 완료\n- **granted = false**: 잠금 대기 중 (블로킹 발생)\n\n### 주요 Lock Mode\n| 모드 | 설명 |\n|------|------|\n| AccessShareLock | SELECT |\n| RowShareLock | SELECT FOR UPDATE |\n| RowExclusiveLock | INSERT/UPDATE/DELETE |\n| AccessExclusiveLock | ALTER TABLE, DROP |`,
    en: `Query the current **lock status** in the database.\n\n### Requirements\n\`\`\`sql\nSELECT\n  l.locktype,\n  l.mode,\n  l.granted,\n  l.pid,\n  a.usename,\n  a.query,\n  a.state\nFROM pg_locks l\nJOIN pg_stat_activity a ON l.pid = a.pid\nWHERE a.datname = current_database()\n  AND l.locktype = 'relation'\nORDER BY l.granted, l.pid;\n\`\`\`\n\n### What are Locks?\n- Mechanism preventing concurrent modification of same data\n- **granted = true**: Lock acquired\n- **granted = false**: Waiting for lock (blocking)\n\n### Key Lock Modes\n| Mode | Description |\n|------|-------------|\n| AccessShareLock | SELECT |\n| RowShareLock | SELECT FOR UPDATE |\n| RowExclusiveLock | INSERT/UPDATE/DELETE |\n| AccessExclusiveLock | ALTER TABLE, DROP |`,
  },
  schema: 'ecommerce', category: 'Monitoring', difficulty: 2,
  hints: {
    ko: ['pg_locks와 pg_stat_activity를 JOIN하여 잠금 정보와 세션 정보를 함께 조회합니다.', 'granted = false인 행이 잠금 대기(블로킹) 중인 세션입니다.', "SELECT l.locktype, l.mode, l.granted, l.pid, a.usename, a.query, a.state FROM pg_locks l JOIN pg_stat_activity a ON l.pid = a.pid WHERE a.datname = current_database() AND l.locktype = 'relation' ORDER BY l.granted, l.pid;"],
    en: ['JOIN pg_locks with pg_stat_activity to see lock info with session details.', 'Rows with granted = false are waiting for locks (blocked).', "SELECT l.locktype, l.mode, l.granted, l.pid, a.usename, a.query, a.state FROM pg_locks l JOIN pg_stat_activity a ON l.pid = a.pid WHERE a.datname = current_database() AND l.locktype = 'relation' ORDER BY l.granted, l.pid;"],
  },
  explanation: {
    ko: `## pg_locks (잠금 모니터링)\n\n### 블로킹 세션 찾기\n\`\`\`sql\n-- 잠금을 대기 중인 세션 (블로킹 피해자)\nSELECT blocked.pid AS blocked_pid,\n       blocked.query AS blocked_query,\n       blocker.pid AS blocker_pid,\n       blocker.query AS blocker_query\nFROM pg_locks blocked_locks\nJOIN pg_stat_activity blocked ON blocked_locks.pid = blocked.pid\nJOIN pg_locks blocker_locks ON blocked_locks.locktype = blocker_locks.locktype\n  AND blocked_locks.relation = blocker_locks.relation\n  AND blocked_locks.pid != blocker_locks.pid\nJOIN pg_stat_activity blocker ON blocker_locks.pid = blocker.pid\nWHERE NOT blocked_locks.granted;\n\`\`\`\n\n### Lock 충돌 매트릭스\n| | AccessShare | RowShare | RowExclusive | AccessExclusive |\n|---|---|---|---|---|\n| AccessShare | - | - | - | X |\n| RowShare | - | - | - | X |\n| RowExclusive | - | - | - | X |\n| AccessExclusive | X | X | X | X |\n\n(X = 충돌, - = 공존 가능)\n\n### DBA 대응\n- 블로킹 세션 식별 후 필요시 \`pg_cancel_backend(pid)\`\n- 장시간 잠금은 \`idle in transaction\` 세션이 원인인 경우 많음\n- \`lock_timeout\` 설정으로 잠금 대기 시간 제한`,
    en: `## pg_locks (Lock Monitoring)\n\n### Find Blocking Sessions\n\`\`\`sql\nSELECT blocked.pid AS blocked_pid,\n       blocked.query AS blocked_query,\n       blocker.pid AS blocker_pid,\n       blocker.query AS blocker_query\nFROM pg_locks blocked_locks\nJOIN pg_stat_activity blocked ON blocked_locks.pid = blocked.pid\nJOIN pg_locks blocker_locks ON blocked_locks.locktype = blocker_locks.locktype\n  AND blocked_locks.relation = blocker_locks.relation\n  AND blocked_locks.pid != blocker_locks.pid\nJOIN pg_stat_activity blocker ON blocker_locks.pid = blocker.pid\nWHERE NOT blocked_locks.granted;\n\`\`\`\n\n### Lock Conflict Matrix\n| | AccessShare | RowShare | RowExclusive | AccessExclusive |\n|---|---|---|---|---|\n| AccessShare | - | - | - | X |\n| RowShare | - | - | - | X |\n| RowExclusive | - | - | - | X |\n| AccessExclusive | X | X | X | X |\n\n(X = conflict, - = compatible)\n\n### DBA Response\n- Identify blocker, then \`pg_cancel_backend(pid)\` if needed\n- Long locks often caused by \`idle in transaction\` sessions\n- Use \`lock_timeout\` to limit lock wait time`,
  },
  expectedQuery: {
    postgresql: "SELECT l.locktype, l.mode, l.granted, l.pid, a.usename, a.query, a.state FROM pg_locks l JOIN pg_stat_activity a ON l.pid = a.pid WHERE a.datname = current_database() AND l.locktype = 'relation' ORDER BY l.granted, l.pid;",
    mysql: "SELECT l.locktype, l.mode, l.granted, l.pid, a.usename, a.query, a.state FROM pg_locks l JOIN pg_stat_activity a ON l.pid = a.pid WHERE a.datname = current_database() AND l.locktype = 'relation' ORDER BY l.granted, l.pid;",
  },
  gradingMode: 'exact', relatedConcepts: ['pg_locks', 'Lock', 'Blocking', 'Monitoring', 'DBA'],
};
